module sine_wave
    //current sine wave is based on phase, rather than a clock
    (
        //phase will overflow if any larger than our table
        //effectively truncating anything outside of our range
        //right now, the possible values are: [0,63]
	    input [DATA_WIDTH-1:0] phase,
        output reg signed [DATA_WIDTH-1:0] amp
    );

    //should be generated by C, but for now, will be hardcoded
    //Right now, we store 32 different sine values.
    //Negative values can be repeated
    reg [DATA_WIDTH-1:0] sine_table [0:SINE_RESOLUTION-1];
    integer i;

    initial begin
        //Define our sine table!
        sine_table = $sine_table;
    end

    always @ (phase) begin
        //the phase is divided into two sections, [0,31] and [32,63] where one set is an inversion of the other
        if (phase > SINE_RESOLUTION-1) begin
            amp <= -1 * sine_table[phase-SINE_RESOLUTION];
        end else begin
            amp <= sine_table[phase];
        end

    end
endmodule